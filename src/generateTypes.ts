import ts from 'typescript';
import { readFile, writeFile } from 'fs/promises';

const filePath = './res/docs.json';
const json = await readFile(filePath);
const decoder = new TextDecoder('utf-16le');
const docs = JSON.parse(decoder.decode(json)) as unknown;
const errors: string[] = [];

if (!docs || !Array.isArray(docs)) {
  throw new Error(`Invalid docs file: ${filePath}`);
}

// const printer = ts.createPrinter();
// const sourceFile = ts.createSourceFile(
//   'docs.ts',
//   '',
//   ts.ScriptTarget.Latest,
//   false,
//   ts.ScriptKind.TS
// );
const file = ts.createSourceFile(
  'source.ts',
  '',
  ts.ScriptTarget.ESNext,
  false,
  ts.ScriptKind.TS
);
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

function printTypescript(node: ts.Node) {
  console.log(printer.printNode(ts.EmitHint.Unspecified, node, file));
}

function getTSPropertyTypeFromValue(value: unknown): ts.TypeNode {
  if (value === null) {
    return ts.factory.createLiteralTypeNode(ts.factory.createNull());
  }
  if (typeof value === 'undefined') {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
  }
  if (typeof value === 'boolean') {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
  }
  if (typeof value === 'number') {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
  }
  if (typeof value === 'string') {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
  }
  if (typeof value === 'bigint') {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BigIntKeyword);
  }
  if (typeof value === 'object') {
    if (Array.isArray(value)) {
      return ts.factory.createArrayTypeNode(
        getTSPropertyTypeFromValue(value[0])
      );
    }
    return ts.factory.createTypeLiteralNode(
      Object.entries(value as Record<string, unknown>).map(([key, value]) => {
        return ts.factory.createPropertySignature(
          undefined,
          key,
          undefined,
          getTSPropertyTypeFromValue(value)
        );
      })
    );
  }
  throw new Error(`Unknown type: ${typeof value}`);
}

const nativeClassRegex = /FactoryGame\.(.*)'/; //Sample: ///Script/CoreUObject.Class'/Script/FactoryGame.FGItemDescriptor'
const docsLength = docs.length;
const nativeClasses: Map<string, ts.TypeNode> = new Map();
for (let i = 0; i < docsLength; i++) {
  const doc = docs[i];
  if (!doc || typeof doc !== 'object') {
    continue;
  }
  if (!('NativeClass' in doc) || typeof doc.NativeClass !== 'string') {
    continue;
  }
  if (!('Classes' in doc) || !Array.isArray(doc.Classes)) {
    continue;
  }
  const nativeClass = doc.NativeClass as string;
  const match = nativeClass.match(nativeClassRegex);
  if (!match) {
    continue;
  }
  const nativeClassName = match[1];
  const classes = doc.Classes as Record<string, unknown>[];
  const classesLength = classes.length;
  const fullProperties: Map<string, ts.TypeNode> = new Map();
  const commonProperties: Set<string> = new Set();

  for (let j = 0; j < classesLength; j++) {
    const classObj = classes[j];
    if (!classObj || typeof classObj !== 'object') {
      continue;
    }
    for (const [key, value] of Object.entries(classObj)) {
      if (j !== 0 && !commonProperties.has(key)) {
        commonProperties.delete(key);
        continue;
      }
      const type = getTSPropertyTypeFromValue(value);
      if (fullProperties.has(key)) {
        const existingType = fullProperties.get(key)!;
        if (existingType.kind !== type.kind) {
          console.log(
            `Type mismatch for ${nativeClassName}.${key}, existing: ${
              ts.SyntaxKind[existingType.kind]
            }, new: ${ts.SyntaxKind[type.kind]}`
          );
          if (existingType.kind !== ts.SyntaxKind.UnionType) {
            fullProperties.set(
              key,
              ts.factory.createUnionTypeNode([existingType, type])
            );
          } else {
            const types = (existingType as ts.UnionTypeNode).types;
            if (types.some(t => t.kind === type.kind)) {
              continue;
            }
            fullProperties.set(
              key,
              ts.factory.createUnionTypeNode([...types, type])
            );
          }
        }
        continue;
      }
      fullProperties.set(key, getTSPropertyTypeFromValue(value));
      if (j === 0) {
        commonProperties.add(key);
      }
    }
  }

  nativeClasses.set(
    nativeClassName,
    ts.factory.createTypeLiteralNode(
      Array.from(fullProperties.entries()).map(([key, value]) => {
        return ts.factory.createPropertySignature(
          undefined,
          key,
          commonProperties.has(key)
            ? undefined
            : ts.factory.createToken(ts.SyntaxKind.QuestionToken),
          value
        );
      })
    )
  );
  // printTypescript(nativeClasses.get(nativeClassName)!);
}

// Combine all native classes into one file
let typescriptCode: string = `
// Generated by src/parseDocs.ts
`;
const TopLevelUnionTypes = [];
for (const [name, type] of nativeClasses.entries()) {
  const typeAlias = ts.factory.createTypeAliasDeclaration(
    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
    name + 'Class',
    undefined,
    type
  );

  const FullNativeClass = ts.factory.createTypeAliasDeclaration(
    ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
    name + '_FullNativeClass',
    undefined,
    ts.factory.createTypeLiteralNode([
      ts.factory.createPropertySignature(
        undefined,
        'NativeClass',
        undefined,
        ts.factory.createLiteralTypeNode(
          ts.factory.createStringLiteral(
            `/Script/CoreUObject.Class'/Script/FactoryGame.${name}'`
          )
        )
      ),
      ts.factory.createPropertySignature(
        undefined,
        'Class',
        undefined,
        ts.factory.createTypeReferenceNode(name + 'Class', undefined)
      ),
    ])
  );

  const text =
    printer.printNode(ts.EmitHint.Unspecified, typeAlias, file) +
    '\n' +
    printer.printNode(ts.EmitHint.Unspecified, FullNativeClass, file);

  typescriptCode += text + '\n\n';

  TopLevelUnionTypes.push(
    ts.factory.createTypeReferenceNode(name + '_FullNativeClass', undefined)
  );
}

typescriptCode +=
  printer.printNode(
    ts.EmitHint.Unspecified,
    ts.factory.createTypeAliasDeclaration(
      ts.factory.createModifiersFromModifierFlags(ts.ModifierFlags.Export),
      'Docs',
      undefined,
      ts.factory.createArrayTypeNode(
        ts.factory.createUnionTypeNode(TopLevelUnionTypes)
      )
    ),
    file
  ) +
  '\n\n' +
  printer.printNode(
    ts.EmitHint.Unspecified,
    ts.factory.createExportDefault(ts.factory.createIdentifier('Docs')),
    file
  );

await writeFile('./src/generated/docs.ts', typescriptCode);
